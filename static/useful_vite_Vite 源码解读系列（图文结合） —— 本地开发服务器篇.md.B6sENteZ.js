import{_ as i,l as t,k as a,ae as s}from"./chunks/framework.BFFW23Ds.js";const k=JSON.parse('{"title":"Vite 源码解读系列（图文结合） —— 本地开发服务器篇","description":"","frontmatter":{"label":"vite"},"headers":[{"level":2,"title":"项目目录","slug":"项目目录","link":"#项目目录","children":[]},{"level":2,"title":"vite dev","slug":"vite-dev","link":"#vite-dev","children":[]},{"level":2,"title":"vite 支持的配置","slug":"vite-支持的配置","link":"#vite-支持的配置","children":[]},{"level":2,"title":"配置断点调试","slug":"配置断点调试","link":"#配置断点调试","children":[]},{"level":2,"title":"加载配置文件","slug":"加载配置文件","link":"#加载配置文件","children":[]},{"level":2,"title":"配置收集 - resolveConfig","slug":"配置收集-resolveconfig","link":"#配置收集-resolveconfig","children":[{"level":3,"title":"处理插件执行顺序","slug":"处理插件执行顺序","link":"#处理插件执行顺序","children":[]},{"level":3,"title":"合并插件配置","slug":"合并插件配置","link":"#合并插件配置","children":[]},{"level":3,"title":"处理 alias","slug":"处理-alias","link":"#处理-alias","children":[]},{"level":3,"title":"读取环境变量配置","slug":"读取环境变量配置","link":"#读取环境变量配置","children":[]},{"level":3,"title":"导出配置","slug":"导出配置","link":"#导出配置","children":[]}]},{"level":2,"title":"本地开发服务 - createServer","slug":"本地开发服务-createserver","link":"#本地开发服务-createserver","children":[{"level":3,"title":"文件监听 + 热重载","slug":"文件监听-热重载","link":"#文件监听-热重载","children":[]},{"level":3,"title":"插件容器","slug":"插件容器","link":"#插件容器","children":[]},{"level":3,"title":"中间件机制","slug":"中间件机制","link":"#中间件机制","children":[]},{"level":3,"title":"预构建依赖","slug":"预构建依赖","link":"#预构建依赖","children":[]}]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}],"relativePath":"useful/vite/Vite 源码解读系列（图文结合） —— 本地开发服务器篇.md","filePath":"useful/vite/Vite 源码解读系列（图文结合） —— 本地开发服务器篇.md","lastUpdated":1709394628000}'),e={name:"useful/vite/Vite 源码解读系列（图文结合） —— 本地开发服务器篇.md"},l=s(`<h1 id="vite-源码解读系列-图文结合-——-本地开发服务器篇" tabindex="-1">Vite 源码解读系列（图文结合） —— 本地开发服务器篇 <a class="header-anchor" href="#vite-源码解读系列-图文结合-——-本地开发服务器篇" aria-label="Permalink to &quot;Vite 源码解读系列（图文结合） —— 本地开发服务器篇&quot;">​</a></h1><p>Vite 是一种新型的前端构建工具，能够显著提升前端开发体验。</p><p>我将会使用图文结合的方式，尽量让本篇文章显得不那么枯燥（显然对于源码解读类文章来说，这不是个简单的事情）。</p><p>本篇文章解读的主要是 vite 源码本体，vite 通过 connect 库提供开发服务器，通过中间件机制实现多项开发服务器配置。而 vite 在本地开发时没有借助 webpack 或是 rollup 这样的打包工具，而是通过调度内部 plugin 实现了文件的转译，从而达到小而快的效果。</p><p>好了，话不多说，我们开始吧！</p><h2 id="项目目录" tabindex="-1">项目目录 <a class="header-anchor" href="#项目目录" aria-label="Permalink to &quot;项目目录&quot;">​</a></h2><p>本文阅读的 Vite 源码版本是 <code>2.8.0-beta.3</code>。</p><p>我们先来看看 Vite 这个包的项目目录吧。（如下图）</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-12-19-14.png" alt="" loading="lazy"></p><p>这是一个集成管理的项目，其核心就是在 packages 里面的几个包，我们来分别看看这几个包是做什么的吧。（如下）</p><table tabindex="0"><thead><tr><th>包名</th><th>作用</th></tr></thead><tbody><tr><td>vite</td><td>Vite 主库，负责 Vite 项目的本地开发（插件调度）和生产产物构建（Rollup 调度）</td></tr><tr><td>create-vite</td><td>用于创建新的 Vite 项目，内部存放了多个框架（如 react、vue）的初始化模板</td></tr><tr><td>plugin-vue</td><td>Vite 官方插件，用于提供 Vue 3 单文件组件支持</td></tr><tr><td>plugin-vue-jsx</td><td>Vite 官方插件，用于提供 Vue 3 JSX 支持（通过 专用的 Babel 转换插件）</td></tr><tr><td>plugin-react</td><td>Vite 官方插件，用于提供完整的 React 支持</td></tr><tr><td>plugin-legacy</td><td>Vite 官方插件，用于为打包后的文件提供传统浏览器兼容性支持</td></tr><tr><td>playground</td><td>Vite 内置的一些测试用例及 Demo</td></tr></tbody></table><p>这几个源码仓库其实有阅读的价值，但是我们这次还是先专注一下我们本期的主线 —— Vite，从 Vite 开始吧。</p><p>接下来我们重点解读 vite 本地开发服务命令 —— vite / vite dev / vite serve。</p><h2 id="vite-dev" tabindex="-1">vite dev <a class="header-anchor" href="#vite-dev" aria-label="Permalink to &quot;vite dev&quot;">​</a></h2><p>我们来了解一下 vite dev 命令，也就是本地开发服务的内部工作流程。</p><p>vite dev 调用了内部的 createServer 方法创建了一个服务，这个服务利用中间件（第三方）支持了多种能力（如 跨域、静态文件服务器等），并且内部创建了 watcher 持续监听着文件的变更，进行实时编译和热重载。</p><p>而 createServer 做的事情就是我们需要关注的核心逻辑。</p><p>在 createServer 方法中，首先进行了对配置的收集工作 —— resolveConfig。</p><h2 id="vite-支持的配置" tabindex="-1">vite 支持的配置 <a class="header-anchor" href="#vite-支持的配置" aria-label="Permalink to &quot;vite 支持的配置&quot;">​</a></h2><p>我们先了解下 vite 项目支持的配置，有些配置可以通过命令行传递，有些只能在配置文件里指定，也可以全部通过 vite.config.js 来进行配置。</p><table tabindex="0"><thead><tr><th>配置名称</th><th>配置说明</th></tr></thead><tbody><tr><td>configFile</td><td>指定配置文件位置，默认读取根目录下的 vite.config.js 配置文件</td></tr><tr><td>envFile</td><td>指定环境变量配置文件位置，默认读取根目录下的 .env 环境变量配置文件</td></tr><tr><td>root</td><td>项目的根目录，默认值是执行命令的目录 —— process.cwd()</td></tr><tr><td>base</td><td>类似于 webpack 中的 publicPath，也就是资源的公共基础路径</td></tr><tr><td>server</td><td>本地运行时的服务设置，比如设置 host（主机地址）、port（运行端口）</td></tr><tr><td>build</td><td>构建生产产物时的选项</td></tr><tr><td>preview</td><td>预览选项，在使用了 build 命令后，可以运行 vite preview 对产物进行预览</td></tr><tr><td>publicDir</td><td>静态资源目录，用于放置不需要编译的静态资源，默认值是 public 目录</td></tr><tr><td>cacheDir</td><td>缓存文件夹，用于放置 vite 预编译好的一些缓存依赖，加速 vite 编译速度</td></tr><tr><td>mode</td><td>编译模式，本地运行时默认值是 development，构建生产产物时默认是 production</td></tr><tr><td>define</td><td>定义全局变量，其中开发环境每一项会被定义在全局，而生产环境将会被静态替换</td></tr><tr><td>plugins</td><td>配置 vite 项目的插件</td></tr><tr><td>resolve</td><td>参考 <a href="https://cn.vitejs.dev/config/" target="_blank" rel="noreferrer">https://cn.vitejs.dev/config/</a></td></tr><tr><td>css</td><td>关于 css 文件的编译选项</td></tr><tr><td>json</td><td>关于 json 文件的编译选项</td></tr><tr><td>esbuild</td><td>转换 ts 文件</td></tr><tr><td>assetsInclude</td><td>设置需要被 picomatch 模式（一种文件匹配模式）独立处理的文件类型</td></tr><tr><td>optimizeDeps</td><td>依赖优化选项</td></tr><tr><td>ssr</td><td>ssr 的相关选项</td></tr><tr><td>logLevel</td><td>调整控制台输出的级别</td></tr><tr><td>customLogger</td><td>自定义 logger，该选项没有暴露，是一个内部选项</td></tr><tr><td>clearScreen</td><td>默认为 true，配置为 false 后，每次重新编译不会清空之前的内容</td></tr><tr><td>envDir</td><td>用于加载环境变量配置文件 .env 的目录，默认为当前根目录</td></tr><tr><td>envPrefix</td><td>环境变量的前缀，带前缀的环境变量将会被注入到项目中</td></tr><tr><td>worker</td><td>配置 bundle 输出类型、plugins 以及 Rollup 配置项</td></tr></tbody></table><h2 id="配置断点调试" tabindex="-1">配置断点调试 <a class="header-anchor" href="#配置断点调试" aria-label="Permalink to &quot;配置断点调试&quot;">​</a></h2><p>参考<a href="./如何调试 vite.html">这篇文章</a>。</p><h2 id="加载配置文件" tabindex="-1">加载配置文件 <a class="header-anchor" href="#加载配置文件" aria-label="Permalink to &quot;加载配置文件&quot;">​</a></h2><p>resolveConfig 的第一步就是加载项目目录的配置文件，如果没有指定配置文件位置，会自动在根目录下寻找 vite.config.js、vite.config.mjs、vite.config.ts、vite.config.cjs。</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-12-46-39.png" alt="" loading="lazy"></p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-12-47-53.png" alt="" loading="lazy"></p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-12-48-22.png" alt="" loading="lazy"></p><p>在读取配置文件后，会将配置文件和初始化配置进行合并，然后得到一份配置。（如下图）</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-12-54-59.png" alt="" loading="lazy"></p><h2 id="配置收集-resolveconfig" tabindex="-1">配置收集 - resolveConfig <a class="header-anchor" href="#配置收集-resolveconfig" aria-label="Permalink to &quot;配置收集 - resolveConfig&quot;">​</a></h2><p>在 createServer 的开头，调用了 resolveConfig 函数，进行配置收集。</p><p>我们先来看看 resolveConfig 都做了哪些事情吧。</p><h3 id="处理插件执行顺序" tabindex="-1">处理插件执行顺序 <a class="header-anchor" href="#处理插件执行顺序" aria-label="Permalink to &quot;处理插件执行顺序&quot;">​</a></h3><p>首先，resolveConfig 内部处理了插件排序规则，对应下面的排序规则。</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-12-58-39.png" alt="" loading="lazy"></p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-12-59-43.png" alt="" loading="lazy"></p><p>在后续处理的过程中，插件将按照对应的排序规则先后执行，这样能够让插件更好地工作在各个生命周期节点。</p><h3 id="合并插件配置" tabindex="-1">合并插件配置 <a class="header-anchor" href="#合并插件配置" aria-label="Permalink to &quot;合并插件配置&quot;">​</a></h3><p>在插件排序完成后，vite 的插件暴露了一个配置 config 字段，可以通过设置该属性，使插件能够新增或改写 vite 的一些配置。（如下图）</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-13-01-42.png" alt="" loading="lazy"></p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-13-03-51.png" alt="" loading="lazy"></p><h3 id="处理-alias" tabindex="-1">处理 alias <a class="header-anchor" href="#处理-alias" aria-label="Permalink to &quot;处理 alias&quot;">​</a></h3><p>然后，resolveConfig 内部处理了 alias 的逻辑，将指定的 alias 替换成对应的路径。</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-13-58-27.png" alt="" loading="lazy"></p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-13-58-03.png" alt="" loading="lazy"></p><h3 id="读取环境变量配置" tabindex="-1">读取环境变量配置 <a class="header-anchor" href="#读取环境变量配置" aria-label="Permalink to &quot;读取环境变量配置&quot;">​</a></h3><p>接下来，resolveConfig 内部找到 env 的配置目录（默认为根目录），然后在目录中读取对应的 env 环境变量配置文件。我们可以看看内部的读取规则优先级（如下图）</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-09-05.png" alt="" loading="lazy"></p><p>可以看出，读取的优先级分别是 .env.[mode].local、.env.[mode]。如果不存在对应 mode 的配置文件，则会尝试去寻找 .env.local、.env 配置文件，读取到配置文件后，使用 doteenv 将环境变量写入到项目中；如果这些环境变量配置文件都不存在的话，则会返回一个空对象。</p><p>该环境变量配置文件并不影响项目运行，所以不配置也没有什么影响。</p><h3 id="导出配置" tabindex="-1">导出配置 <a class="header-anchor" href="#导出配置" aria-label="Permalink to &quot;导出配置&quot;">​</a></h3><p>接下来，vite 初始化了构建配置，也就是文档中的 build 属性，详情可以参照构建选项文档。</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-11-43.png" alt="" loading="lazy"></p><p>最后，resolveConfig 处理了一些 publicDir、cacheDir 目录后，导出了下面这份配置。</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-14-54.png" alt="" loading="lazy"></p><p>resolveConfig 内部还有一些额外的工作处理，主要是收集内部插件集合（如下图），还有配置一些废弃选项警告信息。</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-16-42.png" alt="" loading="lazy"></p><h2 id="本地开发服务-createserver" tabindex="-1">本地开发服务 - createServer <a class="header-anchor" href="#本地开发服务-createserver" aria-label="Permalink to &quot;本地开发服务 - createServer&quot;">​</a></h2><p>回到 createServer 方法，该方法通过 resolveConfig 拿到配置后，第一时间处理了 ssr（服务端渲染）的逻辑。</p><p>如果使用了服务端渲染，则会通过别的方式进行本地开发调试。</p><p>如果不是服务端渲染，则会创建一个 http server 用于本地开发调试，同时创建一个 websocket 服务用于热重载。（如下图）</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-19-19.png" alt="" loading="lazy"></p><h3 id="文件监听-热重载" tabindex="-1">文件监听 + 热重载 <a class="header-anchor" href="#文件监听-热重载" aria-label="Permalink to &quot;文件监听 + 热重载&quot;">​</a></h3><p>然后，vite 创建了一个 FSWatcher 对象，用于监听本地项目文件的变动。（这里使用的是 chokidar 库）</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> watcher</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chokidar.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root), {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ignored: [</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 忽略 node_modules 目录的文件变更</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &#39;**/node_modules/**&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 忽略 .git 目录的文件变更</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &#39;**/.git/**&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 忽略用户传入的 \`ignore\` 目录文件的变更</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ignored) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ignored </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [ignored])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ignoreInitial: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ignorePermissionErrors: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    disableGlobbing: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">watchOptions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FSWatcher</span></span></code></pre></div><p>然后，vite 将多个属性和方法组织成了一个 server 对象，该对象负责启动本地开发服务，也负责服务后续的开发热重载。</p><p>接下来，我们看看 watcher 是如何做页面热重载的吧，原理就是监听到文件变更后，重新触发插件编译，然后将更新消息发送给客户端。（如下图）</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-24-35.png" alt="" loading="lazy"></p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-26-50.png" alt="" loading="lazy"></p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-28-48.png" alt="" loading="lazy"></p><p>客户端</p><p>update：加载对应的更新文件并执行</p><p>full-reload：刷新页面</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-31-03.png" alt="" loading="lazy"></p><h3 id="插件容器" tabindex="-1">插件容器 <a class="header-anchor" href="#插件容器" aria-label="Permalink to &quot;插件容器&quot;">​</a></h3><p>接下来，vite 创建了插件容器（pluginContainer），用于在构建的各个阶段调用插件的钩子。（如下图）</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-34-52.png" alt="" loading="lazy"></p><p>在服务启动时，调用 buildStart</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-36-51.png" alt="" loading="lazy"></p><p>pluginContainer 内部，调用每个插件的 buildStart 方法</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-39-21.png" alt="" loading="lazy"></p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-40-59.png" alt="" loading="lazy"></p><h3 id="中间件机制" tabindex="-1">中间件机制 <a class="header-anchor" href="#中间件机制" aria-label="Permalink to &quot;中间件机制&quot;">​</a></h3><p>接下来是一些内部中间件的处理，当配置开发服务器选项时，vite 内部通过 connect 框架的中间件能力来提供支持。（如下图）</p><p>cors 跨域选项，使用 &#39;cors&#39; 库中间件支持。middlewares（原 app）是 connnect 实例。</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-42-54.png" alt="" loading="lazy"></p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-45-53.png" alt="" loading="lazy"></p><p>其中，对 public 目录、公共路径等多项配置都是通过 connect + 中间件实现的，充分地利用了第三方库的能力，而没有重复造轮子。</p><h3 id="预构建依赖" tabindex="-1">预构建依赖 <a class="header-anchor" href="#预构建依赖" aria-label="Permalink to &quot;预构建依赖&quot;">​</a></h3><p>接下来，vite 内部对项目中使用到的依赖进行的预构建，一来是为了兼容不同的 ES 模块规范，二来是为了提升加载性能。（如下图）</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-55-42.png" alt="" loading="lazy"></p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-55-27.png" alt="" loading="lazy"></p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-56-21.png" alt="" loading="lazy"></p><p>准备工作就绪后，vite 内部调用 startServer 启动本地开发服务器。（如下）</p><p><img src="https://my-course-public.oss-cn-shanghai.aliyuncs.com/public/img/2023-07-09-14-58-23.png" alt="" loading="lazy"></p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>至此，vite 本身的源码部分就解析完了。</p><p>可以看出，在本地开发时，vite 主要依赖 插件 + 中间件体系 来提供能力支持。因为本地开发时只涉及到少量编译工作，所以非常的快。只有在构建生产产物时，vite 才用到了 rollup 进行构建。</p>`,99),n=[l];function p(r,c,h,d,o,g){return a(),t("div",null,n)}const m=i(e,[["render",p]]);export{k as __pageData,m as default};
