import{_ as s,l as n,k as a,ae as e}from"./chunks/framework.BFFW23Ds.js";const g=JSON.parse('{"title":"Symlinked node_modules structure","description":"","frontmatter":{"label":"npm"},"headers":[{"level":2,"title":"node_modules 的符号链接结构","slug":"node-modules-的符号链接结构","link":"#node-modules-的符号链接结构","children":[]}],"relativePath":"useful/npm, yarn, pnpm/Symlinked `node_modules` structure.md","filePath":"useful/npm, yarn, pnpm/Symlinked `node_modules` structure.md","lastUpdated":1709816942000}'),p={name:"useful/npm, yarn, pnpm/Symlinked `node_modules` structure.md"},o=e(`<h1 id="symlinked-node-modules-structure" tabindex="-1">Symlinked <code>node_modules</code> structure <a class="header-anchor" href="#symlinked-node-modules-structure" aria-label="Permalink to &quot;Symlinked \`node_modules\` structure&quot;">​</a></h1><p>原文链接：<a href="https://pnpm.io/symlinked-node-modules-structure" target="_blank" rel="noreferrer">https://pnpm.io/symlinked-node-modules-structure</a></p><h2 id="node-modules-的符号链接结构" tabindex="-1">node_modules 的符号链接结构 <a class="header-anchor" href="#node-modules-的符号链接结构" aria-label="Permalink to &quot;node_modules 的符号链接结构&quot;">​</a></h2><blockquote><p>这篇文章仅仅描述没有 peer dependencies 的 pnpm，是怎么构建 node_modules 结构的。</p></blockquote><p>pnpm 的 node_modules 布局使用符号链接来生成一个嵌套的依赖结构。</p><p>在项目的 node_modules/.pnpm 里，每一个包都指向一个硬链接，指向内容寻址的仓库。让我们看看，假设你安装了 foo@1.0.0，它依赖 bar@1.0.0。pnpm 将会硬链接这两个包到 <code>&lt;store&gt;</code>下，像下面这样：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node_modules</span></span>
<span class="line"><span>└── .pnpm</span></span>
<span class="line"><span>    ├── bar@1.0.0</span></span>
<span class="line"><span>    │   └── node_modules</span></span>
<span class="line"><span>    │       └── bar -&gt; &lt;store&gt;/bar</span></span>
<span class="line"><span>    │           ├── index.js</span></span>
<span class="line"><span>    │           └── package.json</span></span>
<span class="line"><span>    └── foo@1.0.0</span></span>
<span class="line"><span>        └── node_modules</span></span>
<span class="line"><span>            └── foo -&gt; &lt;store&gt;/foo</span></span>
<span class="line"><span>                ├── index.js</span></span>
<span class="line"><span>                └── package.json</span></span></code></pre></div><p>现在 node_modules 下面还只有“真实”文件。一旦所有的包被硬链接到 node_modules，符号链接将会被创建以构建嵌套的依赖结构图。</p><p>你可能已经注意到，两个包都被硬链接进 node_modules 文件里的一个子文件。（foo@1.0.0/node_modules/foo）。之所以这么做是因为：</p><ol><li><p><strong>允许包导入他们自己</strong>。foo 应该能 <code>require(&#39;foo/package.json&#39;)</code> 或 <code>import * as package from &quot;foo/package.json&quot;</code></p></li><li><p><strong>避免循环符号链接</strong>。一个包的依赖被放置到和这个包相同层级的目录中。对于 Node.js 而言这两者并没有什么不同：依赖是在这个包的 node_modules 里面还是在这个包的上层目录下的 node_modules 里面。（由此知道，为什么 npm 和 yarn 要将包全部提升到 node_modules 下同一层级）</p></li></ol><p>安装的下一步是用符号链接依赖。bar 将会被链接到 foo@1.0.0/node_modules 目录下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node_modules</span></span>
<span class="line"><span>└── .pnpm</span></span>
<span class="line"><span>    ├── bar@1.0.0</span></span>
<span class="line"><span>    │   └── node_modules</span></span>
<span class="line"><span>    │       └── bar -&gt; &lt;store&gt;/bar</span></span>
<span class="line"><span>    └── foo@1.0.0</span></span>
<span class="line"><span>        └── node_modules</span></span>
<span class="line"><span>            ├── foo -&gt; &lt;store&gt;/foo</span></span>
<span class="line"><span>            └── bar -&gt; ../../bar@1.0.0/node_modules/bar</span></span></code></pre></div><p>下一步，直接依赖将会被处理。foo 将被符号链接进根 node_modules 目录，因为 foo 是这个项目的依赖。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node_modules</span></span>
<span class="line"><span>├── foo -&gt; ./.pnpm/foo@1.0.0/node_modules/foo</span></span>
<span class="line"><span>└── .pnpm</span></span>
<span class="line"><span>    ├── bar@1.0.0</span></span>
<span class="line"><span>    │   └── node_modules</span></span>
<span class="line"><span>    │       └── bar -&gt; &lt;store&gt;/bar</span></span>
<span class="line"><span>    └── foo@1.0.0</span></span>
<span class="line"><span>        └── node_modules</span></span>
<span class="line"><span>            ├── foo -&gt; &lt;store&gt;/foo</span></span>
<span class="line"><span>            └── bar -&gt; ../../bar@1.0.0/node_modules/bar</span></span></code></pre></div><p>这是一个非常简单的例子。然而，不管有多少的依赖和多深的依赖图，布局都将保持这个结构。</p><p>我们再添加 qar@2.0.0 作为 foo 和 bar 的依赖。新结构将会这样：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node_modules</span></span>
<span class="line"><span>├── foo -&gt; ./.pnpm/foo@1.0.0/node_modules/foo</span></span>
<span class="line"><span>└── .pnpm</span></span>
<span class="line"><span>    ├── bar@1.0.0</span></span>
<span class="line"><span>    │   └── node_modules</span></span>
<span class="line"><span>    │       ├── bar -&gt; &lt;store&gt;/bar</span></span>
<span class="line"><span>    │       └── qar -&gt; ../../qar@2.0.0/node_modules/qar</span></span>
<span class="line"><span>    ├── foo@1.0.0</span></span>
<span class="line"><span>    │   └── node_modules</span></span>
<span class="line"><span>    │       ├── foo -&gt; &lt;store&gt;/foo</span></span>
<span class="line"><span>    │       ├── bar -&gt; ../../bar@1.0.0/node_modules/bar</span></span>
<span class="line"><span>    │       └── qar -&gt; ../../qar@2.0.0/node_modules/qar</span></span>
<span class="line"><span>    └── qar@2.0.0</span></span>
<span class="line"><span>        └── node_modules</span></span>
<span class="line"><span>            └── qar -&gt; &lt;store&gt;/qar</span></span></code></pre></div><p>正如你所见到的，即使现在依赖图更深了（foo 依赖 bar，bar 又依赖 qar），文件系统的目录深度依旧是相同的。</p><p>这个布局第一次看起来可能有点奇怪，但它完全兼容 Node 的处理模块算法。</p><p>当处理模块时，Node 会忽略符号链接，所以当 bar 从 foo@1.0.0/node_modules/foo/index.js 文件被引入 required 时，Node 不会使用 foo@1.0.0/node_modules/bar（它是个符号链接），相反，bar 会被解析到它的真实位置（bar@1.0.0/node_modules/bar）。</p><p>因此，bar 也能够解析在 bar@1.0.0/node_modules 下的依赖。</p><p>这个布局的最大好处是，仅是真实在项目的依赖里的包才能够被获取。而一个扁平化的 node_modules 结构，所有被提升的包都可以被获取到。</p>`,22),l=[o];function d(t,i,r,c,u,m){return a(),n("div",null,l)}const b=s(p,[["render",d]]);export{g as __pageData,b as default};
