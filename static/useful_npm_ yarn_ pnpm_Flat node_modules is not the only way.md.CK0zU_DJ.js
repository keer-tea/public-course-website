import{_ as s,l as n,k as a,ae as p}from"./chunks/framework.BFFW23Ds.js";const _=JSON.parse('{"title":"Flat node_modules is not the only way","description":"","frontmatter":{"label":"npm"},"headers":[],"relativePath":"useful/npm, yarn, pnpm/Flat node_modules is not the only way.md","filePath":"useful/npm, yarn, pnpm/Flat node_modules is not the only way.md","lastUpdated":1709816942000}'),e={name:"useful/npm, yarn, pnpm/Flat node_modules is not the only way.md"},l=p(`<p>原文链接：<a href="https://pnpm.io/blog/2020/05/27/flat-node-modules-is-not-the-only-way" target="_blank" rel="noreferrer">https://pnpm.io/blog/2020/05/27/flat-node-modules-is-not-the-only-way</a></p><h1 id="flat-node-modules-is-not-the-only-way" tabindex="-1">Flat node_modules is not the only way <a class="header-anchor" href="#flat-node-modules-is-not-the-only-way" aria-label="Permalink to &quot;Flat node_modules is not the only way&quot;">​</a></h1><p>新的 pnpm 用户经常问我关于 pnpm 生成的奇怪的 node_modules 结构。为什么它不是平铺的？它的所有子依赖项去哪了？</p><p>我将假设这篇文章的读者已经熟悉为什么 npm 或 yarn 生成的 node_modules 结构是扁平化的。如果你不理解为什么 npm 3 开始使用扁平化的 node_modules，你可以寻找以前的历史在<a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html" target="_blank" rel="noreferrer">Why should we use pnpm?</a></p><p>所以为什么 pnpm 的 node_modules 是不寻常的？让我们创建两个目录，一个执行 npm add express，一个执行 pnpm add express。</p><p>执行 npm 的目录长这样：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.bin</span></span>
<span class="line"><span>accepts</span></span>
<span class="line"><span>array-flatten</span></span>
<span class="line"><span>body-parser</span></span>
<span class="line"><span>bytes</span></span>
<span class="line"><span>content-disposition</span></span>
<span class="line"><span>cookie-signature</span></span>
<span class="line"><span>cookie</span></span>
<span class="line"><span>debug</span></span>
<span class="line"><span>depd</span></span>
<span class="line"><span>destroy</span></span>
<span class="line"><span>ee-first</span></span>
<span class="line"><span>encodeurl</span></span>
<span class="line"><span>escape-html</span></span>
<span class="line"><span>etag</span></span>
<span class="line"><span>express</span></span></code></pre></div><p>执行 pnpm 的长这样：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.pnpm</span></span>
<span class="line"><span>.modules.yaml</span></span>
<span class="line"><span>express</span></span></code></pre></div><p>所以所有的依赖去哪了？在 node_modules 里面仅仅有 .pnpm 目录，一个符号链接 express。是的，我们仅仅下载了 express，所以它是你的项目仅能获取的包。</p><p>Let&#39;s see what is inside express:</p><p>让我们看看符号链接 express 里面都有些什么：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>▾ node_modules</span></span>
<span class="line"><span>  ▸ .pnpm</span></span>
<span class="line"><span>  ▾ express</span></span>
<span class="line"><span>    ▸ lib</span></span>
<span class="line"><span>      History.md</span></span>
<span class="line"><span>      index.js</span></span>
<span class="line"><span>      LICENSE</span></span>
<span class="line"><span>      package.json</span></span>
<span class="line"><span>      Readme.md</span></span>
<span class="line"><span>  .modules.yaml</span></span></code></pre></div><p>express 没有 node_modules？那 express 的所有依赖去哪了？</p><p>这只不过是一个戏法。express 仅仅是一个符号链接。当 Node.js 解析依赖时，它会使用它们真实的位置，所以它不会保存符号链接。但你可能会问 express 真实的位置在哪。</p><p>在这里：</p><p><code>node_modules/.pnpm/express@4.17.1/node_modules/express.</code></p><p>好的，那么现在我们知道了 .pnpm 文件夹的意图了。.pnpm/ 下以扁平的方式存放着所有的包，所以每一个包你都能通过这个路径格式在这个目录下找到。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;</span></span></code></pre></div><p>我们叫它虚拟存储目录。</p><p>这个扁平化的结构避免了因为嵌套的 node_modules 而导致的长路径问题，但是依旧保持了包之间的隔离。</p><p>现在我们看看 express 的真实位置里面：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  ▾ express</span></span>
<span class="line"><span>    ▸ lib</span></span>
<span class="line"><span>      History.md</span></span>
<span class="line"><span>      index.js</span></span>
<span class="line"><span>      LICENSE</span></span>
<span class="line"><span>      package.json</span></span>
<span class="line"><span>      Readme.md</span></span></code></pre></div><p>这是一个骗局吗？这里依旧缺少 node_modules。第二个 pnpm 的 node_modules 结构诀窍就是，这个包的依赖和这个包的真实位置在一个相同级别的目录位置下。</p><p>所以 express 的依赖没有在 <code>.pnpm/express@4.17.1/node_modules/express/node_modules/</code>，而是在 <code>.pnpm/express@4.17.1/node_modules/:</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>▾ node_modules</span></span>
<span class="line"><span>  ▾ .pnpm</span></span>
<span class="line"><span>    ▸ accepts@1.3.5</span></span>
<span class="line"><span>    ▸ array-flatten@1.1.1</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>    ▾ express@4.16.3</span></span>
<span class="line"><span>      ▾ node_modules</span></span>
<span class="line"><span>        ▸ accepts</span></span>
<span class="line"><span>        ▸ array-flatten</span></span>
<span class="line"><span>        ▸ body-parser</span></span>
<span class="line"><span>        ▸ content-disposition</span></span>
<span class="line"><span>        ...</span></span>
<span class="line"><span>        ▸ etag</span></span>
<span class="line"><span>        ▾ express</span></span>
<span class="line"><span>          ▸ lib</span></span>
<span class="line"><span>            History.md</span></span>
<span class="line"><span>            index.js</span></span>
<span class="line"><span>            LICENSE</span></span>
<span class="line"><span>            package.json</span></span>
<span class="line"><span>            Readme.md</span></span></code></pre></div><p>express 的所有依赖都是符号链接，指向在 node_modules/.pnpm 下相应的目录。把 express 的依赖安放在一个级别提升的目录允许避免循环的符号链接。</p><p>所以正如你所看到的，即使 pnpm 的 node_modules 结构在一开始开起来不寻常：</p><ol><li>但它完全兼容 Node.js</li><li>包和它们的依赖被很好的分组管理</li></ol><p>带有 peer dependencies 的包结构会比较复杂一点。但是思想都是相同的：使用符号链接生成一个带有扁平目录的嵌套结构。</p>`,30),o=[l];function t(i,d,c,r,m,u){return a(),n("div",null,o)}const y=s(e,[["render",t]]);export{_ as __pageData,y as default};
